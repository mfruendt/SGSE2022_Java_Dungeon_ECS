package newgame.items;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

import de.fhbielefeld.pmdungeon.vorgaben.dungeonCreator.DungeonWorld;
import de.fhbielefeld.pmdungeon.vorgaben.graphic.Animation;
import de.fhbielefeld.pmdungeon.vorgaben.interfaces.IAnimatable;
import de.fhbielefeld.pmdungeon.vorgaben.interfaces.IEntity;
import de.fhbielefeld.pmdungeon.vorgaben.tools.Point;
import newgame.animations.ChestAnimations;
import newgame.inventory.Inventory;
import newgame.logger.GameEventsLogger;
import newgame.logger.InventoryConsoleLogVisitor;
import newgame.logger.InventoryLogVisitor;
import newgame.logger.LogMessages;

/**
 * Chest with items
 * @author Dominik Haacke
 *
 * @param <T> item Type, can be InventoryItem for multiple types
 */
public class Chest<T extends Item> extends Inventory implements IAnimatable, IEntity
{
	private boolean opening, opened;
	
	private int frameCounter;
	
	private enum AnimationStates
    {
        UNOPENED(0),
        OPENING(1),
        OPEN(2);

        /** Enum element index
         *
         */
        final int index;

        /** Constructor of the enum elements
         *
         * @param index Index of the enum
         */
        AnimationStates(final int index)
        {
            this.index = index;
        }

        /** Get the index of an enum element
         *
         * @return Index of the element
         */
        public int getIndex()
        {
            return index;
        }
    }
	
	private final List<Animation> animations;

	private AnimationStates activeAnimation;

  	private Point currentPosition;

  	private DungeonWorld currentDungeonWorld;
	
	/**
	 * Creates a Chest with a maximum capacity of items, every item takes 1 space
	 * @param capacity maximum item count
	 */
	public Chest(final int capacity)
	{
		super(capacity);
		animations = new ArrayList<>();
		animations.add(AnimationStates.UNOPENED.getIndex(), ChestAnimations.getAnimation(ChestAnimations.Animations.CHEST_UNOPENED));
        animations.add(AnimationStates.OPENING.getIndex(), ChestAnimations.getAnimation(ChestAnimations.Animations.CHEST_OPENING));
        animations.add(AnimationStates.OPEN.getIndex(), ChestAnimations.getAnimation(ChestAnimations.Animations.CHEST_OPEN));
		
		activeAnimation = AnimationStates.UNOPENED;
	}
	
	@Override
	public Point getPosition() 
	{
		return currentPosition;
	}

	@Override
	public boolean deleteable() 
	{
		return false;
	}
	
	/** Set the chest position to a new random location inside the level
    *
    */
	public void findRandomPosition()
	{
		this.currentPosition = new Point(currentDungeonWorld.getRandomPointInDungeon());
	}

	/** Get the current animation of the chest
    *
    * @return The current animation of the chest
    */
	@Override
	public Animation getActiveAnimation()
	{
		return animations.get(activeAnimation.getIndex());
	}

	/** Change the level in which the chest currently is.
    * 
    * The start position in the new level will be randomized.
    *
    * @param level New level
    */
	public void setLocation(final DungeonWorld level)
	{
		if (level == null)
		{
			GameEventsLogger.getLogger().severe(LogMessages.ILLEGAL_ARGUMENT.toString());
			throw new IllegalArgumentException();
		}
		this.currentDungeonWorld = level;
		findRandomPosition();
	}
	
	/**
	 * Sets the opened and opening flags to true, if it wasn't opened before, the flags update the animations in updateAnimations()
	 */
	public void open()
	{
		if(!opened)
		{
			opened = true;
			opening = true;
		}
	}
	
	public void close()
	{
		if (this.opened)
		{
			opened = false;
		}
	}

	/**
	 * If the opened and opening flags have been set the animations starts and the chest will open. 
	 * If the chest is fully open all items will be logged.
	 */
	public void updateAnimations()
	{
		if(opened)
		{
			activeAnimation = AnimationStates.OPENING;
			frameCounter ++;
			if(frameCounter >= 12)
			{
				opening = false;
				activeAnimation = AnimationStates.OPEN;
				this.log(new InventoryConsoleLogVisitor());
			}
		}
		else
		{
			activeAnimation = AnimationStates.UNOPENED;
		}
	}
	
	/**
	 * Check if the chest is fully opened
	 * @return chest open
	 */
	public boolean isFullyOpen()
	{
		return !opening && opened;
	}
	
	/**
	 * Fill the chest with 1 - maxNumberOfItems items randomly. The items are generated by the ItemGenerator.
	 */
	public void fillRandom()
	{
		int numOfItems = ThreadLocalRandom.current().nextInt(1, this.capacity);
		for(int i = 0; i < numOfItems; i ++)
		{
			this.addItem(ItemGenerator.generateItem());
		}
	}

	/**
	 * Update the Animations and draw the Chest
	 */
	@Override
	public void update() 
	{
		updateAnimations();
		this.draw();
	}

	/**
	 * Log all items on console
	 * 
	 * @param inventoryLogVisitor interface to log items
	 */
	public void log(InventoryLogVisitor inventoryLogVisitor)
	{
		inventoryLogVisitor.log(this);
	}
}
